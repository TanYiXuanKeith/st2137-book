{
  "hash": "c5f0056f7670a74295d1b02f3339fb52",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Introduction to R\"\n---\n\n::: {.cell}\n\n:::\n\n\n\n\n## Introduction\n\nR actually evolved from the **S** language, which was first developed by Rick\nBecker, John Chambers and Allan Wilks. S was created with the following goals in\nmind:\n\n1.  S was conceived as a powerful tool for statistical modelling. It enabled you\n    to specify and fit statistical models to your data, assess the goodness of\n    fit and then display parameter estimates, standard errors and predicted\n    values derived from the model. It provided the means to define and\n    manipulate data. The intent was to provide the user with maximum control\n    over the model-fitting process.\n2.  S was to be used for data exploration (tabulating, sorting data, drawing\n    plots to look for trends, etc.)\n3.  It was to be used as a sophisticated calculator to evaluate complex\n    arithmetic expressions, and as a very flexible and general object-oriented\n    programming language to perform more extensive data manipulation.\n\nLater on, S evolved into S-PLUS, which became very costly. **R**oss Ihaka and\n**R**obert Gentleman from the University of Auckland, decided to write a\nstripped-down version of S, which was R. Five years later, version 1.0.0 of R\nwas released on 29 Feb 2000. As of Dec 2023, the latest version of R is 4.3.2 It\nis maintained by the [@rmanual].\n\n## Installing R and Rstudio\n\nTo download R, go to [CRAN, the Comprehensive R Archive\nNetwork](https://cran.r-project.org/), download the version for your operating\nsystem and install it.\n\nA new major version is released once a year, and there are 2 - 3 minor releases\neach year. Upgrading is painful, but it gets worse if you wait to upgrade.\n\n::: callout-important\nFor our class, please ensure that you have version 4.4.1 or later. Functions in\nolder versions work differently, so you might face problems or differences with\nsome of the codes in the notes.\n:::\n\n![Base R](figs/base_r_gui.PNG){#fig-base-R fig-alt=\"Base R GUI\"\nfig-align=\"center\"}\n\nAfter installing, you can start using R straightaway. However, the basic GUI is\nnot very user-friendly, as you can see from @fig-base-R. Instead of using the\nbasic GUI for R, we are going to use RStudio. RStudio is an Integrated\nDevelopment Environment (IDE) for R. It provides several features that base R\ndoes not, including:\n\n-   A history of previous plots made.\n-   The ability to browse the objects in our workspace more easily.\n\nThe installation file for RStudio can be obtained from [this\nURL](https://www.rstudio.com/products/rstudio/download/). It is updated a couple\nof times a year. Make sure you have at least version 2024.09.x for our course.\n\n![Rstudio interface](figs/rstudio_gui.PNG){#fig-rstudio\nfig-alt=\"Rstudio GUI\" fig-align=\"center\"}\n\nHere's a quick orientation of the panels in Rstudio, with reference to\n@fig-rstudio.\n\n-   Panel 1 is the \\textbf{console}.\n    -   This is where you type R commands.\n    -   The output from these commands or functions will also be seen here.\n    -   Use the $\\uparrow$ key to scroll through previously entered commands.\n-   Panel 2 contains the *History* and *Environment* tabs.\n    -   The *History* tab displays all commands that have been previously\n        entered in the current session.\n    -   These commands can be sent directly to the source code panel or the\n        console panel.\n    -   The *Environment* tab in this panel has a list of items that have been\n        created in the current session.\n-   Panel 3 contains the *Files*, *Plots* and *Help* tabs.\n    -   The *Files* tab contains a directory structure that allows one to choose\n        and open files in the source code editor.\n    -   Through the *Plots* tab, one can access all plots that have been created\n        in the current session.\n    -   The *Help* tab displays the documentation for R functions.\n-   Panel 4 contains the source code editor.\n    -   This where you edit R scripts.\n    -   You can hit **Ctrl-Enter** to execute a command (in the console panel)\n        while your cursor is in the source code panel.\n    -   You can also highlight code and the editor and execute it directly in\n        the console panel.\n\n## Basic Data Structures in R\n\nProbably the four most frequently used data structures in R are the following:\n\n-   **Vector**: A set of elements of the same mode (logical; numeric;\n    character).\n-   **Matrix**: A set of elements appearing in rows and columns, where the\n    elements are of the same mode.\n-   **Dataframe**: This is similar to the matrix object in that it is\n    2-dimensional. However, columns in a dataframe can have different modes.\n    Rows typically contain different observations from your study or\n    measurements from your experiment. The columns contain the values of\n    different variables which may be of different modes.\n-   **List**: A list is a generalization of a vector -- it represents a\n    collection of data objects.\n\n## Creating Basic Objects in R\n\n### Vectors\n\nTo create a vector in R, the simplest way is to use the combine function `c()`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#creating a vector of numbers:\nnumeric_vec <- c(2,4,6,8,10)\nnumeric_vec\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  2  4  6  8 10\n```\n\n\n:::\n\n```{.r .cell-code}\n# creating a vector of strings/characters:\nstring_vec <-c(\"weight\", \"height\", \"gender\")\nstring_vec\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"weight\" \"height\" \"gender\"\n```\n\n\n:::\n\n```{.r .cell-code}\n#creating a Boolean vector (T/F):\nlogical_vec <- c(TRUE, TRUE, FALSE)\nlogical_vec\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE  TRUE FALSE\n```\n\n\n:::\n:::\n\n\n\n\nWhen we need to create a vector that defines groups (of Females followed by\nMales, for instance), we can turn to a convenient function called `rep()`. This\nfunction replicates elements of vectors and lists. The syntax is as follows:\n`rep(a, b)` will replicate the item `a`, `b` times. Here are some examples:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nr1 <- rep(2,3)\nr1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 2 2\n```\n\n\n:::\n\n```{.r .cell-code}\nr2 <- rep(c(1,2),3)\nr2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 1 2 1 2\n```\n\n\n:::\n\n```{.r .cell-code}\nr3 <- rep(c(6,3),c(2,4))\nr3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 6 6 3 3 3 3\n```\n\n\n:::\n\n```{.r .cell-code}\nr4 <- rep(string_vec, 2)\nr4\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"weight\" \"height\" \"gender\" \"weight\" \"height\" \"gender\"\n```\n\n\n:::\n:::\n\n\n\n\nOn other occasions, we may need to create an index vector, along the rows of a\ndataset. The `seq()` function is useful for this purpose. It creates a sequence\nof numbers that are evenly spread out.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseq(from=2, to=10, by=2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  2  4  6  8 10\n```\n\n\n:::\n\n```{.r .cell-code}\nseq(from=2, to=10, length = 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  2  4  6  8 10\n```\n\n\n:::\n\n```{.r .cell-code}\nseq(2, 5, 0.8)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2.0 2.8 3.6 4.4\n```\n\n\n:::\n\n```{.r .cell-code}\nseq(2, 5, 0.8) * 2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 4.0 5.6 7.2 8.8\n```\n\n\n:::\n:::\n\n\n\n\nThe final example above, where the sequence vector of length 4 is multiplied by\na scalar 2, is an example of the *recycling rule* in R -- the shorter vector is\nrecycled to match the length of the longer one. This rule applies in all\nbuilt-in R functions. Try to use this rule to your advantage when using R.\n\nIf you only need to create a vector of integers that increase by 1, you do not\neven need `seq()`. The `:` colon operator will handle the task.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ns1 <- 2:5\ns1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 3 4 5\n```\n\n\n:::\n:::\n\n\n\n\n### Matrices\n\nThus far, we have been creating vectors. Matrices are higher dimensional\nobjects. To create a matrix, we use the `matrix()` function. The syntax is as\nfollows: `matrix(v,r,c)` will take the values from vector `v` and create a\nmatrix with `r` rows and `c` columns. R is *column-major*, which means that, by\ndefault, the matrix is filled column-by-column, not row-by-row.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nv <- c(1:6)\nm1 <- matrix(v, nrow=2, ncol=3)\nm1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    3    5\n[2,]    2    4    6\n```\n\n\n:::\n\n```{.r .cell-code}\nm2 <- matrix(v, nrow=2, ncol=3, byrow=TRUE)\nm2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    2    3\n[2,]    4    5    6\n```\n\n\n:::\n:::\n\n\n\n\nNew rows (or columns) can be added to an existing matrix using the command\n`rbind()` (resp. `cbind()`).\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- c(1,2,3,4)\nb <- c(5,6,7,8)\nab_row <- rbind(a,b)\nab_row\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  [,1] [,2] [,3] [,4]\na    1    2    3    4\nb    5    6    7    8\n```\n\n\n:::\n\n```{.r .cell-code}\nab_col <- cbind(ab_row, c(9,10))\nab_col\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  [,1] [,2] [,3] [,4] [,5]\na    1    2    3    4    9\nb    5    6    7    8   10\n```\n\n\n:::\n:::\n\n\n\n\n### Dataframes\n\nNow let's turn to dataframes, which are the most common object we are going to\nuse for storing data in R. A datafame is a tabular object, like a matrix, but\nthe columns can be of different types; some can be numeric and some can be\ncharacter, for instance. Think of a dataframe as an object with rows and\ncolumns:\n\n-   The rows contain different **observations or measurements**;\n-   The columns contain the values of different **variables**.\n\nAs a general guideline, we should try to store our data in a format where *a\nsingle variable is not spread across columns*.\n\n::: {#exm-tidy-1 style=\"background-color: #D5D1D164; padding: 20px\"}\n### Tidy Data\n\nConsider an experiment where there are three treatments (control, pre-heated and\npre-chilled), and two measurements per treatment. The response variable is store\nin the following dataframe:\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n\n| Control| Pre_heated| Pre_chilled|\n|-------:|----------:|-----------:|\n|     6.1|        6.3|         7.1|\n|     5.9|        6.2|         8.2|\n\n\n:::\n:::\n\n\n\n\nThe above format is probably convenient for recording data. However, the\nresponse variable has been spread across three columns. The *tidy* version of\nthe dataset is:\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n\n| Response|Treatment   |\n|--------:|:-----------|\n|      6.1|control     |\n|      5.9|control     |\n|      6.3|pre_heated  |\n|      6.2|pre_heated  |\n|      7.1|pre_chilled |\n|      8.2|pre_chilled |\n\n\n:::\n:::\n\n\n\n\nThe second version is more amenable to computing conditional summaries, making\nplots and for modeling in R.\n:::\n\nDataframes can be created from matrices, and they can also be created from\nindividual vectors. The function `as.data.frame()` converts a matrix into a\ndataframe, with generic column names assigned.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf1 <- as.data.frame(m1)\ndf1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  V1 V2 V3\n1  1  3  5\n2  2  4  6\n```\n\n\n:::\n:::\n\n\n\n\nIf we intend to pack individual vectors into a dataframe, we use the function\n`data.frame()`. We can also specify custom column names when we call this\nfunction.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\na <- c(11,12)\nb <- c(13,14)\ndf2 <- data.frame(col1 = a, col2 = b)\ndf2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  col1 col2\n1   11   13\n2   12   14\n```\n\n\n:::\n:::\n\n\n\n\n### Lists\n\nFinally, we turn to lists. You can think of a list in R as a very general basket\nof objects. The objects do not have to be of the same type or length. The\nobjects can be lists themselves. Lists are created using the `list( )` function;\nelements within a list are accessed using the `$` notation, or by using the\nnames of the elements in the list.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nls1 <- list(A=seq(1, 5, by=2), B=seq(1, 5, length=4))\nls1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n$A\n[1] 1 3 5\n\n$B\n[1] 1.000000 2.333333 3.666667 5.000000\n```\n\n\n:::\n\n```{.r .cell-code}\nls1[[2]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.000000 2.333333 3.666667 5.000000\n```\n\n\n:::\n\n```{.r .cell-code}\nls1[[\"B\"]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.000000 2.333333 3.666667 5.000000\n```\n\n\n:::\n\n```{.r .cell-code}\nls1$A\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 3 5\n```\n\n\n:::\n:::\n\n\n\n\n::: {#exm-list style=\"background-color: #D5D1D164; padding: 20px\"}\n### Extracting p-values\n\nThe `iris` dataset is a very famous dataset that comes with R. It contains\nmeasurements on the flowers of three different species. Let us conduct a\n2-sample $t$-test, and extract the $p$-value.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsetosa <- iris$Sepal.Length[iris$Species == \"setosa\"]\nvirginica <- iris$Sepal.Length[iris$Species == \"virginica\"]\n\nt_test_out <- t.test(setosa, virginica)\nstr(t_test_out) \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nList of 10\n $ statistic  : Named num -15.4\n  ..- attr(*, \"names\")= chr \"t\"\n $ parameter  : Named num 76.5\n  ..- attr(*, \"names\")= chr \"df\"\n $ p.value    : num 3.97e-25\n $ conf.int   : num [1:2] -1.79 -1.38\n  ..- attr(*, \"conf.level\")= num 0.95\n $ estimate   : Named num [1:2] 5.01 6.59\n  ..- attr(*, \"names\")= chr [1:2] \"mean of x\" \"mean of y\"\n $ null.value : Named num 0\n  ..- attr(*, \"names\")= chr \"difference in means\"\n $ stderr     : num 0.103\n $ alternative: chr \"two.sided\"\n $ method     : chr \"Welch Two Sample t-test\"\n $ data.name  : chr \"setosa and virginica\"\n - attr(*, \"class\")= chr \"htest\"\n```\n\n\n:::\n:::\n\n\n\n\n`str( )` prints the *structure* of an R object. From the output above, we can\ntell that the output object is a list with 10 elements. The particular element\nwe need to extract is `p.value`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nt_test_out$p.value\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 3.966867e-25\n```\n\n\n:::\n:::\n\n\n\n:::\n\n## Reading Data into R\n\nIt is uncommon that we will be creating dataframes by hand, as we have been\ndoing so far. It is more common that we will be reading in a dataset from a file\nin order to perform analysis on it. Thus, at this point, let's sidetrack a\nlittle and discuss how we can read data into R as a dataframe.\n\nThe two most common functions for this purpose are `read.table()` and\n`read.csv()`. The former is used when our data is contained in a text file, with\nspaces or tabs separating columns. The latter function is for reading in files\nwith comma-separated-values. If our data is stored as a text file, it is always\na good idea to open it and inspect it before getting R to read it in. Text files\ncan be opened with any text editor; `csv` files can also be opened by Microsoft\nExcel. When we do so, we should look out for a few things:\n\n-   Are there column names in the first row, or does the data actually begin in\n    line 1?\n-   Is it spaces or commas that separate columns?\n-   Are there trailing values in the last few lines of the file?\n\nThe file `crab.txt` contains measurements on crabs. If you open up the file\noutside of R, you should observe that the first line of the file contains column\nnames. By the way, `head()` is a convenient function for inspecting the first\nfew rows of a dataframe. There is a similar function `tail()` for inspecting the\n*last* few rows.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata1 <- read.table(\"data/crab.txt\")\nhead(data1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     V1    V2    V3     V4     V5\n1 color spine width satell weight\n2     3     3  28.3      8  3.050\n3     4     3  22.5      0  1.550\n4     2     1  26.0      9  2.300\n5     4     3  24.8      0  2.100\n6     4     3  26.0      4  2.600\n```\n\n\n:::\n:::\n\n\n\n\nThe data has not been read in correctly. To fix this, we need to inform R that\nthe first row functions as the column names/headings.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata1 <- read.table(\"data/crab.txt\", header=TRUE)\nhead(data1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  color spine width satell weight\n1     3     3  28.3      8   3.05\n2     4     3  22.5      0   1.55\n3     2     1  26.0      9   2.30\n4     4     3  24.8      0   2.10\n5     4     3  26.0      4   2.60\n6     3     3  23.8      0   2.10\n```\n\n\n:::\n:::\n\n\n\n\nIf the first line of the data file does not contain the names of the variables,\nwe can create a vector beforehand to store and then use the names.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvarnames <- c(\"Subject\", \"Gender\", \"CA1\", \"CA2\", \"HW\")\ndata2 <- read.table(\"data/ex_1.txt\", header = FALSE,  \n                    col.names = varnames)\ndata2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Subject Gender CA1 CA2 HW\n1      10      M  80  84  A\n2       7      M  85  89  A\n3       4      F  90  86  B\n4      20      M  82  85  B\n5      25      F  94  94  A\n6      14      F  88  84  C\n```\n\n\n:::\n:::\n\n\n\n\nThe use of `read.csv()` is very similar, but it is applicable when the fields\nwithin each line of the input file are separated by commas instead of tabs or\nspaces.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata3 <- read.csv(\"data/ex_1_comma.txt\",  header = FALSE)\ndata3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  V1 V2 V3 V4 V5\n1 10  M 80 84  A\n2  7  M 85 89  A\n3  4  F 90 86  B\n4 20  M 82 85  B\n5 25  F 94 94  A\n6 14  F 88 84  C\n```\n\n\n:::\n:::\n\n\n\n\n## Accessing Parts of Dataframes\n\nBoth the functions above create a dataframe in R. Now we turn to the task of\naccessing a subset of rows and/or columns of a dataframe. The notation uses\nrectangular brackets, along with a comma inside these brackets to distinguish\nthe row and column specifiers.\n\nTo access all rows from a particular set of columns, we leave the row column\nspecification empty.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata3[, 2:4]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  V2 V3 V4\n1  M 80 84\n2  M 85 89\n3  F 90 86\n4  M 82 85\n5  F 94 94\n6  F 88 84\n```\n\n\n:::\n:::\n\n\n\n\nTo retrieve a subset of rows, we use the space *before* the comma.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata3[1:3, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  V1 V2 V3 V4 V5\n1 10  M 80 84  A\n2  7  M 85 89  A\n3  4  F 90 86  B\n```\n\n\n:::\n:::\n\n\n\n\nIndividual columns can be retrieved from a dataframe (as a vector) using the `$`\noperator. These columns can then be used to retrieve only the rows that satisfy\ncertain conditions. In order to achieve this task, we turn to logical vectors.\nThe following code returns only the rows corresponding to Gender equal to\n\\`\\`M''.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata2[data2$Gender == \"M\", ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Subject Gender CA1 CA2 HW\n1      10      M  80  84  A\n2       7      M  85  89  A\n4      20      M  82  85  B\n```\n\n\n:::\n:::\n\n\n\n\nLogical vectors contain TRUE/FALSE values in their components. These vectors can\nbe combined with logical operations to yield only the rows that satisfy all\nconditions. The `&` operator is the AND operator. Below, we return all rows\nwhere Gender is equal to \\`\\`M'' and CA2 is greater than 85.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata2[data2$Gender == \"M\" & data2$CA2 > 85, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Subject Gender CA1 CA2 HW\n2       7      M  85  89  A\n```\n\n\n:::\n:::\n\n\n\n\nFor your reference , the table below contains all the logical operators in R.\n\n| Operator | Description              |\n|----------|--------------------------|\n| `<`      | less than                |\n| `>`      | greater than             |\n| `<=`     | less than or equal to    |\n| `>=`     | greater than or equal to |\n| `==`     | equal to                 |\n| `!=`     | not equal to             |\n| `x | y`  | (vectorised) OR          |\n| `x & y`  | (vectorised) AND         |\n\nThe `$` operator is both a getter and a setter, so we can also use it to add new\ncolumns to the dataframe. The following command creates a new column named `id`,\nthat contains a running sequence of integers beginning from 1; the new column\nessentially contains row numbers.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata2$id <- 1:NROW(data2)\n```\n:::\n\n\n\n\nBefore we leave this section on dataframes, we shall touch on how we can\nrearrange the dataframe according to particular columns in either ascending or\ndescending order.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata2[order(data2$CA1), ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Subject Gender CA1 CA2 HW id\n1      10      M  80  84  A  1\n4      20      M  82  85  B  4\n2       7      M  85  89  A  2\n6      14      F  88  84  C  6\n3       4      F  90  86  B  3\n5      25      F  94  94  A  5\n```\n\n\n:::\n\n```{.r .cell-code}\n# arranges in reverse order:\ndata2[rev(order(data2$CA1)), ] \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  Subject Gender CA1 CA2 HW id\n5      25      F  94  94  A  5\n3       4      F  90  86  B  3\n6      14      F  88  84  C  6\n2       7      M  85  89  A  2\n4      20      M  82  85  B  4\n1      10      M  80  84  A  1\n```\n\n\n:::\n:::\n\n\n\n\n## Loops in R\n\n`while` loops execute a set of instructions as long as a particular condition\nholds true. On the other hand, `for` loops iterate over a set of integers,\nexecute a set of instructions each time. The syntax for a `while` loop is as\nfollows. The condition is checked at the beginning of each iteration. As long as\nit is TRUE, the set of R expressions within the curly braces will be executed.\n\n::: panel-tabset\n### While Loops\n\nThe general syntax for a `while` loop is as follows:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwhile( <logical condition> ) {\n  R expressions\n  ...\n}\n```\n:::\n\n\n\n\nHere is an example of a `while` loop that increments a value until it reaches\n10.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 0 \nS <- 0\nwhile(x<=10) {\n  S <- S + x  \n  x <- x + 1\n}\nS\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 55\n```\n\n\n:::\n:::\n\n\n\n\n### For Loops\n\nThe general syntax for a `for` loop is as follows:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor(<index> in <set> ) {\n  R expressions\n  ...\n}\n```\n:::\n\n\n\n\nThe \"set\" can be a sequence generated by the colon operator, or it can be any\nvector. Here is the same code from the `while` loop. Notice that `x` does not\nhave to be initialised.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nS <- 0\nfor(x in 1:10){\n  S <- S + x\n}\nS\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 55\n```\n\n\n:::\n:::\n\n\n\n:::\n\nAs a second example, consider these lines of R code, which prints out all\nsquares of integers from 1 to 5. The `cat( )` function concatenates a given\nsequence of strings and prints them to the console. We shall see more of it in a\nfew sections down.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 0            \ntest <- TRUE \n\nwhile(test) {\n  x <- x+1 \n  test <- x<6\n  cat(x^2, test, \"\\n\") \n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n1 TRUE \n4 TRUE \n9 TRUE \n16 TRUE \n25 TRUE \n36 FALSE \n```\n\n\n:::\n:::\n\n\n\n\n## Redirecting R Output\n\nThe `cat()` function can be used to print informative statements as our loop is\nrunning. This can be very helpful in debugging our code. It works by simply\njoining any strings given to it, and then printing them out to the console. The\nargument `\"\\n\"` instructs R to print a newline character after the strings.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncat(\"The current number is\", x^2, \"\\n\") \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nThe current number is 36 \n```\n\n\n:::\n:::\n\n\n\n\nWhen we are running a job in the background, we may want the output to print to\na file so that we can inspect it later at our convenience. That is where the\n`sink()` function comes in.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsink(\"data/datasink_ex1.txt\")      # turn the sink on\nx <- 0            \ntest <- TRUE \n\nwhile(test) {\n  x <- x+1 \n  test <- isTRUE(x<6)  \n  cat(x^2, test, \"\\n\")             # This will be written to the file.\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n1 TRUE \n4 TRUE \n9 TRUE \n16 TRUE \n25 TRUE \n36 FALSE \n```\n\n\n:::\n\n```{.r .cell-code}\nsink()                             # turn the sink off \n```\n:::\n\n\n\n\nWhen we have finished working with a dataframe, we may want save it to a file.\nFor this purpose, we can use the following code. Once executed, the dataframe\n`data2` will be written to a csv file named `ex_1_with_IQ.csv` in the `data/`\ndirectory.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite.csv(data2, \"data/ex_1_with_IQ.csv\")\n```\n:::\n\n\n\n\n## User-Defined Functions in R\n\nWe have already seen several useful functions in R, e.g. `read.csv` and `head`.\nHere is a list of other commonly used functions.\n\n| Function    | Description                         |\n|-------------|-------------------------------------|\n| `max(x)`    | Maximum value of x                  |\n| `min(x)`    | Minimum value of x                  |\n| `sum(x)`    | Total of all the values in x        |\n| `mean(x)`   | Arithmetic average values in x      |\n| `median(x)` | Median value of x                   |\n| `range(x)`  | Vector of length 2: min(x), max(x)  |\n| `var(x)`    | Sample variance of x                |\n| `cor(x, y)` | Correlation between vectors x and y |\n| `sort(x)`   | Sorted version of x                 |\n\nR is a fully-fledged programming language, so it is also possible to write our\nown functions in R. To define a function for later use in R, the syntax is as\nfollows:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfn_name <- function(arguments) {\n  R expressions\n  ...\n  Returned object\n\n}\n```\n:::\n\n\n\n\nThe final line of the function definition will determine what gets returned when\nthe function is executed. Here is an example of a function that computes the\ncircumference of a circle of given radius.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncircumference <- function(r) {\n  2*pi*r\n}\ncircumference(1.3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 8.168141\n```\n\n\n:::\n:::\n\n\n\n\n## Miscellaneous\n\n### Getting Help\n\nAll functions in R are documented. When you need to find out more about the\narguments of a function, or if you need examples of code that is guaranteed to\nwork, then do look up the help page (even before turning to stackexchange). The\nhelp pages within R are accessible even if you are offline.\n\nTo access the help page of a particular function, use the following command:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?mean\n```\n:::\n\n\n\n\nIf you are not sure about the name of the function, you can use the following\nfuzzy search operator to return a page with a list of matching functions:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n??mean\n```\n:::\n\n\n\n\n## Installing Packages\n\nR is an open-source software. Many researchers and inventors of new statistical\nmethodologies contribute to the software through packages[^01-intro_to_r-1]. At\nlast check (Dec 2023), there are 20236 such packages. The packages can be\nperused by name, through [this\nlink](https://cran.r-project.org/web/packages/available_packages_by_name.html).\n\n[^01-intro_to_r-1]: packages are simply *collections* of functions.\n\nTo install one of these packages, you can use `install.packages()`. For\ninstance, this command will install `stringr` (a package for string\nmanipulations) and all it's dependencies on your machine.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"stringr\")\n```\n:::\n\n\n\n\nOnce the installation is complete, we still need to *load* the package whenever\nwe wish to use the functions within it. This is done with the `library()`\nfunction:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(stringr)\n```\n:::\n\n\n\n\nTo access a list of all available functions from a package, use:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhelp(package=\"stringr\")\n```\n:::\n\n\n\n\n## Further Readings\n\nIn our course, we will only be using basic R syntax, functions and plots. You\nmay have heard of the `tidyverse` set of packages, which are a suite of packages\nthat implement a particular paradigm of data manipulation and plotting. You can\nread and learn more about that approach by taking DSA2101, or by learning from\n@wickham2023r.\n\nThe DataCamp courses cover a little more on R e.g. use of `apply` family of\nfunctions. These will be included in our course, so please pay close attention\nin the DataCamp course.\n\n## Heads-Up on Differences with Python\n\nIf you are coming from a Python background, please remember the following key\ndifferences:\n\n-   The colon operator in R is not a slice operator (like in Python)\n-   A list in R is similar to Python in that it is a generic collection, but\n    accessing the elements is done with a `$` notation.\n-   The assignment operator in R is `<-`, but in Python it is `=`.\n-   To create vectors in R, you need to use `c( )`.\n\n\n## References\n\n### Website References\n\n1.  [Iris data](https://en.wikipedia.org/wiki/Iris_flower_data_set): More\n    information on this classic dataset.\n2.  [Installing R](https://cran.r-project.org/)\n3.  [Installing Rstudio](https://posit.co/downloads/)\n",
    "supporting": [
      "01-intro_to_R_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}