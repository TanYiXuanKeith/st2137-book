{
  "hash": "a7c781e54438c5b67822c62bfae1f0a9",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Introduction to Python\"\n---\n\n\n\n\n\n\n\n\n## Introduction\n\nPython is a general-purpose programming language. It is a higher-level language\nthan C, C++ and Java in the sense that a Python program does not have to be\ncompiled before execution.\n\nIt was originally conceived back in the 1980s by Guido van Rossum at Centrum\nWiskunde & Informatica (CWI) in the Netherlands. The language is named after a\nBBC TV show (Guido’s favorite program) “Monty Python's Flying Circus”.\n\nPython reached version 1.0 in January 1994. Python 2.0 was released on October\n16, 2000. Python 3.0, which is backwards-*incompatible* with earlier versions,\nwas released on 3 December 2008.\n\nPython is a very flexible language; it is simple to learn yet is fast enough to \nbe used in production. Over the past ten years, more and more comprehensive data \nscience toolkits (e.g. scikit-learn, NTLK, tensorflow, keras) have been written \nin Python and are now the standard frameworks for those models. \n\nJust like R, Python is an open-source software. It is free to use and extend.\n\n## Installing Python and Jupyter Lab\n\nTo install Python, navigate to the official \n[Python download page](https://www.python.org/downloads/) to obtain the \nappropriate installer for your operating system. \n\n::: {.callout-important}\nFor our class, please ensure that you are using at least Python 3.12.\n:::\n\nThe next step is to create a virtual environment for this course. Virtual \nenvironments are specific to Python. They allow you to retain multiple versions \nof Python, and of packages, on the same computer. Go through the videos on Canvas\nrelevant to your operating system to create a virtual environment and install \nJupyter Lab on your machine.\n\nJupyter notebooks are great for interactive work with Python, but more advanced\nusers may prefer a full-fledged IDE. If you are an advanced user, and are\ncomfortable with an IDE of your own choice (e.g. Spyder or VSCode), feel free to\ncontinue using that to run the codes for this course. \n\n::: {.callout-important}\nEven if you are using Anaconda/Spyder/VSCode, you still need to create a virtual\nenvironment.\n:::\n\nJupyter notebooks consist of cells, which can be of three main types: \n\n* code cells,\n* output cells, and \n* markdown cells. \n\n![Jupyter Lab](figs/jupyter_lab2.png){#fig-jupyter fig-alt=\"Jupyter Lab\" fig-align=\"center\"}\n\nIn @fig-jupyter, the red box labelled 1 is a markdown cell. It can be used to\ncontain descriptions or summary of the code. The cells in the box labelled 2 are\ncode cells. To run the codes from our notes, you can copy and paste the codes\ninto a new cell, and then execute them with Ctrl-Enter. \n\nTry out this Easter egg that comes with any Python installation:\n\n\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport this\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nThe Zen of Python, by Tim Peters\n\nBeautiful is better than ugly.\nExplicit is better than implicit.\nSimple is better than complex.\nComplex is better than complicated.\nFlat is better than nested.\nSparse is better than dense.\nReadability counts.\nSpecial cases aren't special enough to break the rules.\nAlthough practicality beats purity.\nErrors should never pass silently.\nUnless explicitly silenced.\nIn the face of ambiguity, refuse the temptation to guess.\nThere should be one-- and preferably only one --obvious way to do it.\nAlthough that way may not be obvious at first unless you're Dutch.\nNow is better than never.\nAlthough never is often better than *right* now.\nIf the implementation is hard to explain, it's a bad idea.\nIf the implementation is easy to explain, it may be a good idea.\nNamespaces are one honking great idea -- let's do more of those!\n```\n\n\n:::\n:::\n\n\n\n\n\n\nMore information on using Jupyter notebooks can be obtained from \n[this link](https://jupyterlab.readthedocs.io/en/stable/user/interface.html). \n\n## Basic Data Structures in Python\n\nThe main objects in native[^02-python-1] Python that contain data are\n\n[^02-python-1]: i.e., Python without any packages imported.\n\n* **Lists**, which are defined with [ ]. Lists are mutable.\n* **Tuples**, which are defined with ( ). Tuples are immutable.\n* **Dictionaries**,  which are defined with { }. Dictionaries have keys and \n  items. They are also mutable.\n  \nVery soon, we shall see that for statistics, the more common objects we shall\ndeal with are dataframes (from pandas) and arrays (from numpy). However, the\nlatter two require add-on packages; the three object classes listed above are\nbaked into Python.\n\nBy the way, this is what mean by (im)mutable:\n\n\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nx = [1, 3, 5, 7, 8, 9, 10]\n\n# The following is OK, because \"x\" is a list, and hence mutable\nx[3] = 17     \nprint(x)  \n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1, 3, 5, 17, 8, 9, 10]\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.python .cell-code}\n# The following will return an error, because x_tuple is a tuple, and hence \n# immutable.\nx_tuple = (1, 3, 5, 6, 8, 9, 10)\nx_tuple[3] = 17 \n```\n:::\n\n\n\n\n\n\n::: {.callout-note}\nNote that we do *not* need the `c( )` function, like we did in R. This is a \ncommon mistake I make when switching between the two languages.\n:::\n\nHere is how we create lists, tuples and dictionaries.\n\n\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nx_list = [1, 2, 3]\nx_tuple = (1, 2, 3)\nx_dict = {'a': 1, 'b': 2, 'c': 3} # access with x_dict['a']\n```\n:::\n\n\n\n\n\n\n\n## Slice Operator in Python\n\nOne important point to take note is that, contrary to R, Python begins indexing \nof objects starting with 0. Second, the slice operator in Python is a little more \npowerful than in R. It can be used to extract regular sequences from a list, tuple or \nstring easily.\n\nIn general, the syntax is `<list-like object>[a:b]`, where `a` and `b` are integers. \nSuch a call would return the elements at indices `a`, `a+1` until `b-1`. Take note that \nthe end point index is not included.\n\n\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nchar_list = ['P', 'y', 't', 'h', 'o', 'n']\nchar_list[0]           # returns first element\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n'P'\n```\n\n\n:::\n\n```{.python .cell-code}\nchar_list[-1]          # returns last element\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n'n'\n```\n\n\n:::\n\n```{.python .cell-code}\nlen(char_list)         # returns number of elements in list-like object.\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n6\n```\n\n\n:::\n\n```{.python .cell-code}\nchar_list[::2]         # from first to last, every 2 apart.\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n['P', 't', 'o']\n```\n\n\n:::\n:::\n\n\n\n\n\n\nThis indexing syntax is used in the additional packages we use as well, so it is\ngood to know about it. @fig-py-slice displays a pictorial representation of how\npositive and negative indexes work together.\n\n![Positive and negative indices](figs/python_slice.png){#fig-py-slice fig-alt=\"Python slice\" fig-align=\"center\" width=\"55%\"}\n\n## Numpy Arrays\n\nJust like R, Python has several contributed packages that are essential for statistics\nand data analysis. These include `numpy` and `pandas`. These appropriate versions of these\npackages would have been installed if you had used the requirements file when setting up \nPython.\n\n\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport numpy as np\n\narray1 = np.array([1, 2, 3, 4, 5])\narray2 = np.array([6, 7, 8, 9, 10])\nmatrix1 = np.array([array1, array2])\nprint(matrix1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[[ 1  2  3  4  5]\n [ 6  7  8  9 10]]\n```\n\n\n:::\n:::\n\n\n\n\n\n\nThe slice operator can then be used in each dimension of the matrix to subset it. \n\n\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nmatrix1[0, 0::3]       # returns first row, columns 1 and 4\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\narray([1, 4])\n```\n\n\n:::\n\n```{.python .cell-code}\nmatrix1[1, 1:3]        # returns second row, columns 2 and 3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\narray([7, 8])\n```\n\n\n:::\n:::\n\n\n\n\n\n\nThe numpy arrays are objects in Python, with several methods associated with them.\nFor instance, here are a couple and how we can use them:\n\n\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# To obtain the dimensions of an array:\nmatrix1.shape\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n(2, 5)\n```\n\n\n:::\n\n```{.python .cell-code}\n# To transpose a 2-D array\nmatrix1.T\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\narray([[ 1,  6],\n       [ 2,  7],\n       [ 3,  8],\n       [ 4,  9],\n       [ 5, 10]])\n```\n\n\n:::\n:::\n\n\n\n\n\n\nHere is a table with some common operations that you can apply on a numpy array. \nThe objects referred to in the second column are from the earlier lines of code.\n\n| Method      | Description                                 |\n|-------------|---------------------------------------------|\n| `shape`     | Returns dimensions, e.g. `matrix1.shape`    |\n| `T`         | Transposes the array, e.g. `matrix1.T`      |\n| `mean`      | Computes col- or row-wise means, e.g. `matrix1.mean(axis=0)` or `matrix1.mean(axis=1)` |\n| `sum`       | Computes col- or row-wise means, e.g. `matrix1.sum(axis=0)` or `matrix1.sum(axis=1)` |\n| `argmax`    | Return the index corresponding to the max within the specified dimension, e.g. `matrix1.argmax(axis=0)` for the position with the max within each column.  |\n| `reshape`   | To change the dimensions, e.g. `array1.reshape((5,1))` converts the array into a 5x1 matrix |\n\nTo combine arrays, we use the functions `vstack` and `hstack`. These are analogous to \n`rbind` and `cbind` in R.\n\n\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nnp.vstack([matrix1, array1])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\narray([[ 1,  2,  3,  4,  5],\n       [ 6,  7,  8,  9, 10],\n       [ 1,  2,  3,  4,  5]])\n```\n\n\n:::\n\n```{.python .cell-code}\nnp.hstack([array1.reshape((5,1)), \n           array2.reshape((5,1)),\n           matrix1.T])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\narray([[ 1,  6,  1,  6],\n       [ 2,  7,  2,  7],\n       [ 3,  8,  3,  8],\n       [ 4,  9,  4,  9],\n       [ 5, 10,  5, 10]])\n```\n\n\n:::\n:::\n\n\n\n\n\n\n## Pandas DataFrames\n\nThe next important add-on package that we shall work with is `pandas`. It provides a\n`DataFrame` class of objects for working with tabular data, just like `data.frame` \nwithin R. However, there are some syntactic differences with R that we shall get \nto soon. The following command creates a simple pandas \n\n\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport pandas as pd\n\ndata = {'X': [1,2,3,4,5,6], 'Y': [6,5,4,3,2,1]}\ndf = pd.DataFrame(data, columns =['X', 'Y'])\nprint(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   X  Y\n0  1  6\n1  2  5\n2  3  4\n3  4  3\n4  5  2\n5  6  1\n```\n\n\n:::\n:::\n\n\n\n\n\n\nWe will get into the syntax for accessing subsets of the dataframe soon, but for \nnow, here is how we can extract a single column from the dataframe. The resulting\nobject is a pandas Series, which is a lot like a 1-D array, and can be indexed \nlike one as well.\n\n\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\ncol_x = df.X\ncol_x[0:3]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n0    1\n1    2\n2    3\nName: X, dtype: int64\n```\n\n\n:::\n:::\n\n\n\n\n\n\n::: {.callout-note}\nThe built-in objects in Python are lists, tuples and dictionaries. Lists and\ntuples can contain elements of different types, e.g. strings and integers in a\nsingle object. However, they have no dimensions, so to speak of. Numpy arrays\ncan be high-dimensional structures. In addition, the elements have to be\nhomogeneous. For instance, in a 2x2x2 numeric numpy array, every one of the 8\nelements has to be a float point number. Pandas DataFrames are tabular objects,\nwhere, within a column, each element has to be of the same type.\n:::\n\n## Reading Data into Python\n\nLet us begin with the same file that we began with in the topic on R: `crab.txt`. \nIn @sec-01-read-data, we observed that this file contained headings, \nand that the columns \nwere separated by spaces. The `pandas` function to read in such text files \nis `read_table()`. It has numerous optional arguments, but in this case we just \nneed these two:\n\n\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndata1 = pd.read_table('data/crab.txt', header=0, sep=\"\\\\s+\")\ndata1.head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   color  spine  width  satell  weight\n0      3      3   28.3       8    3.05\n1      4      3   22.5       0    1.55\n2      2      1   26.0       9    2.30\n3      4      3   24.8       0    2.10\n4      4      3   26.0       4    2.60\n```\n\n\n:::\n:::\n\n\n\n\n\n\nDo take note of the differences with R - the input to the header argument \ncorresponds to the line number containing the column names. Secondly, the `head()`\nfunction is a method belonging to the DataFrame object.\n\nWhen the file does not contain column names, we can supply them (as a list \nor numpy array) when we read the data in. Here is an example:\n\n\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nvarnames = [\"Subject\", \"Gender\", \"CA1\", \"CA2\", \"HW\"]\ndata2 = pd.read_table('data/ex_1.txt', header=None, \n                      names=varnames, sep=\"\\\\s+\")\ndata2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Subject Gender  CA1  CA2 HW\n0       10      M   80   84  A\n1        7      M   85   89  A\n2        4      F   90   86  B\n3       20      M   82   85  B\n4       25      F   94   94  A\n5       14      F   88   84  C\n```\n\n\n:::\n:::\n\n\n\n\n\n\n## Subsetting DataFrames with Pandas\n\nDataFrames in pandas are indexed for efficient searching and retrieval. When \nsubsetting them, we have to add either `.loc` or `.iloc` and use it with square \nbrackets.\n\nThe `.loc` notation is used when we wish to index rows and columns according \nto their names. The general syntax is `<DataFrame>.loc[ , ]`. A slice operator \ncan be used for each row subset and column subset to be retrieved.\n\n\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# retrieve rows 0,1,2 and columns from color to width\ndata1.loc[0:2, 'color':'width']\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   color  spine  width\n0      3      3   28.3\n1      4      3   22.5\n2      2      1   26.0\n```\n\n\n:::\n\n```{.python .cell-code}\n# retrieve every second row starting from row 0 until row 5, and all columns\ndata1.loc[0:5:2, ]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   color  spine  width  satell  weight\n0      3      3   28.3       8    3.05\n2      2      1   26.0       9    2.30\n4      4      3   26.0       4    2.60\n```\n\n\n:::\n:::\n\n\n\n\n\n\nThe `.iloc` notation is used when we wish to index rows and columns using integer\nvalues. The general syntax is similar; try this and observe the difference with\n`.loc`.\n\n\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndata1.iloc[0:2, 0:2]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   color  spine\n0      3      3\n1      4      3\n```\n\n\n:::\n:::\n\n\n\n\n\n\nIf you notice, the `.iloc` notation respects the rules of the in-built slice\noperator, in the sense that the end point is *not* included in the output. On\nthe other hand, the `.loc` notation includes the end point.\n\nIn data analysis, a common requirement is to subset a dataframe according to \nvalues in columns. Just like in R, this is achieved with logical values.\n\n\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndata2[data2.Gender == \"M\"]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Subject Gender  CA1  CA2 HW\n0       10      M   80   84  A\n1        7      M   85   89  A\n3       20      M   82   85  B\n```\n\n\n:::\n\n```{.python .cell-code}\ndata2[(data2.Gender == \"M\") & (data2.CA2 > 85)]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   Subject Gender  CA1  CA2 HW\n1        7      M   85   89  A\n```\n\n\n:::\n:::\n\n\n\n\n\n\n## Loops in Python\n\nIt is extremely efficient to execute \"for\" loops in Python. Many objects in Python\nare *iterators*, which means they can be iterated over. Lists, tuples and dictionaries\ncan all be iterated over very easily. \n\nBefore getting down to examples, take note that Python does not use curly braces\nto denote code blocks. Instead, these are defined by the number of indentations \nin a line. \n\n\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nfor i in x[:2]:\n  print(f\"The current element is {i}.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nThe current element is 1.\nThe current element is 3.\n```\n\n\n:::\n:::\n\n\n\n\n\n\nNotice how we do not need to set up any running index; the object is just iterated \nover directly. The argument to the `print()` function is an f-string. It is the \nrecommended way to create string literals that can vary according to arguments.\n\nHere is another example of iteration, this time using dictionaries which have\nkey-value pairs. In this case, we iterate over the keys.\n\n\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndict1 = {'holmes': 'male', 'watson': 'male', 'mycroft': 'male', \n         'hudson': 'female', 'moriarty': 'male', 'adler': 'female'}\n# dict1['hudson']\n\nfor x in dict1.keys():\n    print(f\"The gender of {x} is {dict1[x]}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nThe gender of holmes is male\nThe gender of watson is male\nThe gender of mycroft is male\nThe gender of hudson is female\nThe gender of moriarty is male\nThe gender of adler is female\n```\n\n\n:::\n:::\n\n\n\n\n\n\nIn @sec-r-loops, we wrote a block of code that incremented an integer until the \nsquare was greater than 36. Here is the Python version of that code:\n\n\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nx = 0          \ntest = True \n\nwhile test:\n    x += 1  \n    test = x < 6\n    print(f\"{x**2}, {test}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n1, True\n4, True\n9, True\n16, True\n25, True\n36, False\n```\n\n\n:::\n:::\n\n\n\n\n\n\nIt is also straightforward to write a for-loop to perform the above, since we\nknow when the break-point of the loop will be. The `np.arange()` function\ngenerates evenly spaced integers.\n\n\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nfor y in np.arange(6):\n    print(f\"The square of {y} is {y**2}.\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nThe square of 0 is 0.\nThe square of 1 is 1.\nThe square of 2 is 4.\nThe square of 3 is 9.\nThe square of 4 is 16.\nThe square of 5 is 25.\n```\n\n\n:::\n:::\n\n\n\n\n\n\n## User Defined Functions\n\nThe syntax for creating a new function in Python is as follows:\n\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\ndef fn_name(arguments):\n  Python statements\n  ...\n  Returned object\n```\n:::\n\n\n\n\n\n\nHere is the same function as earlier, computing the circumference of a circle \nwith a given radius.\n\n\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\nimport math\n\ndef circumference(radius):\n    return 2 * math.pi * radius \n\ncircumference(1.3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n8.168140899333462\n```\n\n\n:::\n:::\n\n\n\n\n\n\n## Miscellaneous\n\n### Package installation\n\nSo far, we have used numpy and pandas, but we shall need to call upon a few \nother add-on packages we proceed in the course. These include statsmodels, scipy and \nmatplotlib. \n\n### Getting help\n\nMost functions in Python are well-documented. In order to access this \ndocumentation from within a Jupyter notebook, use the `?` operator. For more \ndetails, including the source code, use the `??` operator.  For instance, \nfor more details of the `pd.read_csv()` function, you can execute this command:\n\n\n\n\n\n\n::: {.cell}\n\n```{.python .cell-code}\npd.read_csv?\n```\n:::\n\n\n\n\n\n\nThe internet is full of examples and how-to's for Python; help is typically just \na Google search or a chatGPT query away. However, it is always better to learn \nfrom the ground up instead of through snippets for specific tasks. Please look\nthrough the websites in @sec-web-ref-02 below.\n\n## Major Differences with R\n\nBefore we leave this topic, take note of some very obvious differences with R:\n\n1. The assignment operator in R is `<-`; for Python it is `=`.\n2. When creating vectors in R, you will need `c( )`, but in Python, this is \n   not the case.\n3. R implements it's object oriented mechanism in a different manner from Python.\n   For instance, when plotting with R, you would call `plot(<object>)` but in \n   Python, you would call `<object>.plot()`. In Python, the methods belong to the\n   class, but not in R.\n\n\n## References \n\n### Website References {#sec-web-ref-02}\n\n1. [Beginner's guide to Numpy](https://numpy.org/doc/1.26/user/absolute_beginners.html):\n   This is from the official numpy documentation website.\n2. [10 minutes to Pandas](https://pandas.pydata.org/pandas-docs/stable/user_guide/10min.html): \n   This is a quickstart to pandas, from the official website. You can find more \n   tutorials on this page too.\n3. [Python official documentation](https://docs.python.org/3/): This is from the\nofficial Python page. It contains a tutorial, an overview of all built-in\npackages, and several howto's, including on regular expression. A very good\nwebsite to learn from.\n4. [Python download](https://www.python.org/downloads/)\n5. [Jupyter Lab help](https://jupyterlab.readthedocs.io/en/stable/user/interface.html)\n",
    "supporting": [
      "02-intro_to_python_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}